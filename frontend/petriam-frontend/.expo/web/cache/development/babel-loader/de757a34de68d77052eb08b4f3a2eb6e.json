{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { convertCoordinate } from \"./coordinates\";\nimport { transformPathEvents } from \"./events\";\nexport function transformProps(props) {\n  var _props$coordinates = props.coordinates,\n      coordinates = _props$coordinates === void 0 ? [] : _props$coordinates,\n      _props$holes = props.holes,\n      holes = _props$holes === void 0 ? [] : _props$holes,\n      strokeWidth = props.strokeWidth,\n      strokeColor = props.strokeColor,\n      strokeColors = props.strokeColors,\n      fillColor = props.fillColor,\n      lineCap = props.lineCap,\n      lineJoin = props.lineJoin,\n      miterLimit = props.miterLimit,\n      geodesic = props.geodesic,\n      lineDashPhase = props.lineDashPhase,\n      lineDashPattern = props.lineDashPattern,\n      tappable = props.tappable,\n      radius = props.radius,\n      center = props.center,\n      attribution = props.attribution,\n      opacity = props.opacity;\n\n  if (Array.isArray(strokeColors) && strokeColor.length) {\n    console.warn('`strokeColors` is not supported');\n  }\n\n  var allPolygons = [coordinates].concat(_toConsumableArray(holes)).filter(function (polygon) {\n    return Array.isArray(polygon) && polygon.length;\n  });\n  var positions = allPolygons.map(function (polygon) {\n    return polygon.map(function (coordinate) {\n      return convertCoordinate(coordinate);\n    });\n  });\n  return _objectSpread({\n    positions: positions.length ? positions : undefined,\n    weight: strokeWidth,\n    color: strokeColor,\n    fillColor: fillColor,\n    lineCap: lineCap,\n    lineJoin: lineJoin,\n    dashOffset: lineDashPhase,\n    dashArray: lineDashPattern,\n    interactive: tappable,\n    center: center ? convertCoordinate(center) : undefined,\n    radius: radius,\n    attribution: attribution,\n    opacity: opacity\n  }, transformPathEvents(props));\n}","map":{"version":3,"sources":["/Users/kiraci/Desktop/improvement/petriam/frontend/petriam-frontend/node_modules/react-native-maps/lib/web/Leaflet/utils/transformProps.js"],"names":["convertCoordinate","transformPathEvents","transformProps","props","coordinates","holes","strokeWidth","strokeColor","strokeColors","fillColor","lineCap","lineJoin","miterLimit","geodesic","lineDashPhase","lineDashPattern","tappable","radius","center","attribution","opacity","Array","isArray","length","console","warn","allPolygons","filter","polygon","positions","map","coordinate","undefined","weight","color","dashOffset","dashArray","interactive"],"mappings":";;;;;;;AAAA,SAASA,iBAAT;AACA,SAASC,mBAAT;AAEA,OAAO,SAASC,cAAT,CAAwBC,KAAxB,EAA+B;AACpC,2BAkBIA,KAlBJ,CACEC,WADF;AAAA,MACEA,WADF,mCACgB,EADhB;AAAA,qBAkBID,KAlBJ,CAEEE,KAFF;AAAA,MAEEA,KAFF,6BAEU,EAFV;AAAA,MAGEC,WAHF,GAkBIH,KAlBJ,CAGEG,WAHF;AAAA,MAIEC,WAJF,GAkBIJ,KAlBJ,CAIEI,WAJF;AAAA,MAKEC,YALF,GAkBIL,KAlBJ,CAKEK,YALF;AAAA,MAMEC,SANF,GAkBIN,KAlBJ,CAMEM,SANF;AAAA,MAOEC,OAPF,GAkBIP,KAlBJ,CAOEO,OAPF;AAAA,MAQEC,QARF,GAkBIR,KAlBJ,CAQEQ,QARF;AAAA,MASEC,UATF,GAkBIT,KAlBJ,CASES,UATF;AAAA,MAUEC,QAVF,GAkBIV,KAlBJ,CAUEU,QAVF;AAAA,MAWEC,aAXF,GAkBIX,KAlBJ,CAWEW,aAXF;AAAA,MAYEC,eAZF,GAkBIZ,KAlBJ,CAYEY,eAZF;AAAA,MAaEC,QAbF,GAkBIb,KAlBJ,CAaEa,QAbF;AAAA,MAcEC,MAdF,GAkBId,KAlBJ,CAcEc,MAdF;AAAA,MAeEC,MAfF,GAkBIf,KAlBJ,CAeEe,MAfF;AAAA,MAgBEC,WAhBF,GAkBIhB,KAlBJ,CAgBEgB,WAhBF;AAAA,MAiBEC,OAjBF,GAkBIjB,KAlBJ,CAiBEiB,OAjBF;;AAmBA,MAAIC,KAAK,CAACC,OAAN,CAAcd,YAAd,KAA+BD,WAAW,CAACgB,MAA/C,EAAuD;AACrDC,IAAAA,OAAO,CAACC,IAAR,CAAa,iCAAb;AACD;;AAED,MAAMC,WAAW,GAAG,CAACtB,WAAD,4BAAiBC,KAAjB,GAAwBsB,MAAxB,CAClB,UAAAC,OAAO;AAAA,WAAIP,KAAK,CAACC,OAAN,CAAcM,OAAd,KAA0BA,OAAO,CAACL,MAAtC;AAAA,GADW,CAApB;AAGA,MAAMM,SAAS,GAAGH,WAAW,CAACI,GAAZ,CAAgB,UAAAF,OAAO;AAAA,WACvCA,OAAO,CAACE,GAAR,CAAY,UAAAC,UAAU;AAAA,aAAI/B,iBAAiB,CAAC+B,UAAD,CAArB;AAAA,KAAtB,CADuC;AAAA,GAAvB,CAAlB;AAIA;AACEF,IAAAA,SAAS,EAAEA,SAAS,CAACN,MAAV,GAAmBM,SAAnB,GAA+BG,SAD5C;AAEEC,IAAAA,MAAM,EAAE3B,WAFV;AAGE4B,IAAAA,KAAK,EAAE3B,WAHT;AAIEE,IAAAA,SAAS,EAAEA,SAJb;AAKEC,IAAAA,OAAO,EAAEA,OALX;AAMEC,IAAAA,QAAQ,EAAEA,QANZ;AAOEwB,IAAAA,UAAU,EAAErB,aAPd;AAQEsB,IAAAA,SAAS,EAAErB,eARb;AASEsB,IAAAA,WAAW,EAAErB,QATf;AAUEE,IAAAA,MAAM,EAAEA,MAAM,GAAGlB,iBAAiB,CAACkB,MAAD,CAApB,GAA+Bc,SAV/C;AAWEf,IAAAA,MAAM,EAAEA,MAXV;AAYEE,IAAAA,WAAW,EAAXA,WAZF;AAaEC,IAAAA,OAAO,EAAPA;AAbF,KAcKnB,mBAAmB,CAACE,KAAD,CAdxB;AAgBD","sourcesContent":["import { convertCoordinate } from './coordinates';\nimport { transformPathEvents } from './events';\n\nexport function transformProps(props) {\n  const {\n    coordinates = [],\n    holes = [],\n    strokeWidth,\n    strokeColor,\n    strokeColors,\n    fillColor,\n    lineCap,\n    lineJoin,\n    miterLimit,\n    geodesic,\n    lineDashPhase,\n    lineDashPattern,\n    tappable,\n    radius,\n    center,\n    attribution,\n    opacity,\n  } = props;\n  if (Array.isArray(strokeColors) && strokeColor.length) {\n    console.warn('`strokeColors` is not supported');\n  }\n\n  const allPolygons = [coordinates, ...holes].filter(\n    polygon => Array.isArray(polygon) && polygon.length\n  );\n  const positions = allPolygons.map(polygon =>\n    polygon.map(coordinate => convertCoordinate(coordinate))\n  );\n\n  return {\n    positions: positions.length ? positions : undefined,\n    weight: strokeWidth,\n    color: strokeColor,\n    fillColor: fillColor,\n    lineCap: lineCap,\n    lineJoin: lineJoin,\n    dashOffset: lineDashPhase,\n    dashArray: lineDashPattern,\n    interactive: tappable,\n    center: center ? convertCoordinate(center) : undefined,\n    radius: radius,\n    attribution,\n    opacity,\n    ...transformPathEvents(props),\n  };\n}\n"]},"metadata":{},"sourceType":"module"}