{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { latLngBounds, latLng, Marker } from 'leaflet';\nexport var DEFAULT_ZOOM = 8;\nexport var DEFAULT_CENTER = [37.449811, -122.15745];\nexport function getCoordinatesForElements(markers) {\n  var output = [];\n\n  if (Array.isArray(markers)) {\n    for (var _iterator = _createForOfIteratorHelperLoose(markers), _step; !(_step = _iterator()).done;) {\n      var marker = _step.value;\n      if (marker == null) continue;\n      var coordinate = coordinateFromElement(marker);\n      output.push(coordinate);\n    }\n  } else {\n    output.push(coordinateFromElement(markers));\n  }\n\n  return output;\n}\nexport var coordinateFromElement = function coordinateFromElement(element) {\n  if (element == null) return null;else if (Array.isArray(element)) return convertCoordinate(element);else if (element instanceof Marker) {\n    return convertCoordinate(element.getLatLng());\n  } else if (element.coordinate) {\n    return convertCoordinate(element.coordinate);\n  }\n  throw new Error(\"Leaflet: couldn't infer coordinate from element: \" + element);\n};\n\nfunction getCoord(latitude, longitude) {\n  return {\n    latitude: latitude,\n    longitude: longitude\n  };\n}\n\nexport var convertCoordinateToObject = function convertCoordinateToObject(coordinate) {\n  if (!coordinate) return getCoord.apply(void 0, DEFAULT_CENTER);\n\n  if (Array.isArray(coordinate)) {\n    if (coordinate.length !== 2) {\n      throw new Error('Coordinate should be an array with length of 2: [lat, lng]');\n    }\n\n    return getCoord.apply(void 0, _toConsumableArray(coordinate));\n  }\n\n  return getCoord(coordinate.latitude || coordinate.lat || 0, coordinate.longitude || coordinate.lng || coordinate.lon || 0);\n};\nexport var convertCoordinate = function convertCoordinate(coordinate) {\n  if (!coordinate) return DEFAULT_CENTER;\n\n  if (Array.isArray(coordinate)) {\n    if (coordinate.length !== 2) {\n      throw new Error('Coordinate should be an array with length of 2: [lat, lng]');\n    }\n\n    return coordinate;\n  }\n\n  return [coordinate.latitude || coordinate.lat || 0, coordinate.longitude || coordinate.lng || coordinate.lon || 0];\n};\nexport var convertRegion = function convertRegion(region) {\n  var _convertCoordinate = convertCoordinate(region),\n      _convertCoordinate2 = _slicedToArray(_convertCoordinate, 2),\n      lat = _convertCoordinate2[0],\n      lon = _convertCoordinate2[1];\n\n  return latLngBounds(latLng(lat - region.latitudeDelta / 2, lon, -(region.longitudeDelta / 2)), latLng(lat + region.latitudeDelta / 2, lon, +(region.longitudeDelta / 2)));\n};\nexport var boundsToRegion = function boundsToRegion(bounds) {\n  var _bounds$getCenter = bounds.getCenter(),\n      latitude = _bounds$getCenter.lat,\n      longitude = _bounds$getCenter.lng;\n\n  var longitudeDelta = bounds.getEast() - bounds.getWest();\n  var latitudeDelta = bounds.getNorth() - bounds.getSouth();\n  return {\n    latitude: latitude,\n    longitude: longitude,\n    latitudeDelta: latitudeDelta,\n    longitudeDelta: longitudeDelta\n  };\n};","map":{"version":3,"sources":["/Users/kiraci/Desktop/improvement/petriam/frontend/petriam-frontend/node_modules/react-native-maps/lib/web/Leaflet/utils/coordinates.js"],"names":["latLngBounds","latLng","Marker","DEFAULT_ZOOM","DEFAULT_CENTER","getCoordinatesForElements","markers","output","Array","isArray","marker","coordinate","coordinateFromElement","push","element","convertCoordinate","getLatLng","Error","getCoord","latitude","longitude","convertCoordinateToObject","length","lat","lng","lon","convertRegion","region","latitudeDelta","longitudeDelta","boundsToRegion","bounds","getCenter","getEast","getWest","getNorth","getSouth"],"mappings":"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","sourcesContent":["import { latLngBounds, latLng, Marker } from 'leaflet';\n\nexport const DEFAULT_ZOOM = 8;\nexport const DEFAULT_CENTER = [37.449811, -122.15745];\n\nexport function getCoordinatesForElements(markers) {\n  let output = [];\n\n  if (Array.isArray(markers)) {\n    for (const marker of markers) {\n      if (marker == null) continue;\n      const coordinate = coordinateFromElement(marker);\n      output.push(coordinate);\n    }\n  } else {\n    output.push(coordinateFromElement(markers));\n  }\n\n  return output;\n}\n\nexport const coordinateFromElement = element => {\n  if (element == null) return null;\n  else if (Array.isArray(element)) return convertCoordinate(element);\n  else if (element instanceof Marker) {\n    return convertCoordinate(element.getLatLng());\n  } else if (element.coordinate) {\n    return convertCoordinate(element.coordinate);\n  }\n  throw new Error(`Leaflet: couldn't infer coordinate from element: ${element}`);\n};\n\nfunction getCoord(latitude, longitude) {\n  return {\n    latitude,\n    longitude,\n  };\n}\n\nexport const convertCoordinateToObject = coordinate => {\n  if (!coordinate) return getCoord(...DEFAULT_CENTER);\n  if (Array.isArray(coordinate)) {\n    if (coordinate.length !== 2) {\n      throw new Error('Coordinate should be an array with length of 2: [lat, lng]');\n    }\n    return getCoord(...coordinate);\n  }\n  return getCoord(\n    coordinate.latitude || coordinate.lat || 0,\n    coordinate.longitude || coordinate.lng || coordinate.lon || 0\n  );\n};\nexport const convertCoordinate = coordinate => {\n  if (!coordinate) return DEFAULT_CENTER;\n  if (Array.isArray(coordinate)) {\n    if (coordinate.length !== 2) {\n      throw new Error('Coordinate should be an array with length of 2: [lat, lng]');\n    }\n    return coordinate;\n  }\n  return [\n    coordinate.latitude || coordinate.lat || 0,\n    coordinate.longitude || coordinate.lng || coordinate.lon || 0,\n  ];\n};\n\nexport const convertRegion = region => {\n  const [lat, lon] = convertCoordinate(region);\n  return latLngBounds(\n    latLng(lat - region.latitudeDelta / 2, lon, -(region.longitudeDelta / 2)),\n    latLng(lat + region.latitudeDelta / 2, lon, +(region.longitudeDelta / 2))\n  );\n};\n\nexport const boundsToRegion = bounds => {\n  const { lat: latitude, lng: longitude } = bounds.getCenter();\n  const longitudeDelta = bounds.getEast() - bounds.getWest();\n  const latitudeDelta = bounds.getNorth() - bounds.getSouth();\n\n  return { latitude, longitude, latitudeDelta, longitudeDelta };\n};\n"]},"metadata":{},"sourceType":"module"}