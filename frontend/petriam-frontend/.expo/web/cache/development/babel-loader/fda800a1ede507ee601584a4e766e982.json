{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n\nvar _this = this;\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nexport default (function () {\n  if (__DEV__) {\n    for (var _len = arguments.length, tags = new Array(_len), _key = 0; _key < _len; _key++) {\n      tags[_key] = arguments[_key];\n    }\n\n    var tag = tags.join(' -> ') + \" ->\";\n    var warn = console.warn.bind(_this, tag);\n    return {\n      log: console.log.bind(_this, tag),\n      warn: warn,\n      error: console.error.bind(_this, tag),\n      unsupported: function unsupported(props) {\n        var keys = Object.entries(props).filter(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              value = _ref2[1];\n\n          return value != null;\n        }).map(function (_ref3) {\n          var _ref4 = _slicedToArray(_ref3, 1),\n              key = _ref4[0];\n\n          return key;\n        });\n\n        for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {\n          var key = _step.value;\n          warn(\"Prop `\" + key + \"` is not supported\");\n        }\n      }\n    };\n  }\n\n  return {\n    log: function log() {},\n    warn: function warn() {},\n    error: function error() {},\n    unsupported: function unsupported() {}\n  };\n});","map":{"version":3,"sources":["/Users/kiraci/Desktop/improvement/petriam/frontend/petriam-frontend/node_modules/react-native-maps/lib/web/utils/createLogger.js"],"names":["__DEV__","tags","tag","join","warn","console","bind","log","error","unsupported","props","keys","Object","entries","filter","value","map","key"],"mappings":";;;;;;;;;;AAAA,gBAAe,YAAa;AAC1B,MAAIA,OAAJ,EAAa;AAAA,sCADIC,IACJ;AADIA,MAAAA,IACJ;AAAA;;AACX,QAAMC,GAAG,GAAMD,IAAI,CAACE,IAAL,CAAU,MAAV,CAAN,QAAT;AACA,QAAMC,IAAI,GAAGC,OAAO,CAACD,IAAR,CAAaE,IAAb,CAAkB,KAAlB,EAAwBJ,GAAxB,CAAb;AACA,WAAO;AACLK,MAAAA,GAAG,EAAEF,OAAO,CAACE,GAAR,CAAYD,IAAZ,CAAiB,KAAjB,EAAuBJ,GAAvB,CADA;AAELE,MAAAA,IAAI,EAAJA,IAFK;AAGLI,MAAAA,KAAK,EAAEH,OAAO,CAACG,KAAR,CAAcF,IAAd,CAAmB,KAAnB,EAAyBJ,GAAzB,CAHF;AAILO,MAAAA,WAAW,EAAE,qBAAAC,KAAK,EAAI;AACpB,YAAMC,IAAI,GAAGC,MAAM,CAACC,OAAP,CAAeH,KAAf,EACVI,MADU,CACH;AAAA;AAAA,cAAIC,KAAJ;;AAAA,iBAAeA,KAAK,IAAI,IAAxB;AAAA,SADG,EAEVC,GAFU,CAEN;AAAA;AAAA,cAAEC,GAAF;;AAAA,iBAAWA,GAAX;AAAA,SAFM,CAAb;;AAGA,6DAAkBN,IAAlB;AAAA,cAAWM,GAAX;AAAwBb,UAAAA,IAAI,YAAWa,GAAX,wBAAJ;AAAxB;AACD;AATI,KAAP;AAWD;;AAED,SAAO;AACLV,IAAAA,GADK,iBACC,CAAE,CADH;AAELH,IAAAA,IAFK,kBAEE,CAAE,CAFJ;AAGLI,IAAAA,KAHK,mBAGG,CAAE,CAHL;AAILC,IAAAA,WAJK,yBAIS,CAAE;AAJX,GAAP;AAMD,CAvBD","sourcesContent":["export default (...tags) => {\n  if (__DEV__) {\n    const tag = `${tags.join(' -> ')} ->`;\n    const warn = console.warn.bind(this, tag);\n    return {\n      log: console.log.bind(this, tag),\n      warn,\n      error: console.error.bind(this, tag),\n      unsupported: props => {\n        const keys = Object.entries(props)\n          .filter(([, value]) => value != null)\n          .map(([key]) => key);\n        for (const key of keys) warn(`Prop \\`${key}\\` is not supported`);\n      },\n    };\n  }\n\n  return {\n    log() {},\n    warn() {},\n    error() {},\n    unsupported() {},\n  };\n};\n"]},"metadata":{},"sourceType":"module"}