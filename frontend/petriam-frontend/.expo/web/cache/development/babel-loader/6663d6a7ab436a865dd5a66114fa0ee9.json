{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _excluded = [\"initialRegion\"];\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport { latLngBounds as boundsForCooords, Marker as LeafletMarker } from 'leaflet';\nimport * as React from 'react';\nimport { Map as MapView, TileLayer } from 'react-leaflet';\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport Text from \"react-native-web/dist/exports/Text\";\nimport ReactDOMServer from 'react-dom/server';\nimport createLogger from \"../utils/createLogger\";\nimport { boundsToRegion, convertCoordinate, convertRegion, DEFAULT_CENTER, getCoordinatesForElements } from \"./utils/coordinates\";\nimport withRemoteStyles from \"./utils/withRemoteStyles\";\nimport { transformMapEvents } from \"./utils/events\";\nvar LeafletMap = withRemoteStyles(MapView);\nvar DEFAULT_ZOOM = 6;\nvar logger = createLogger('Leaflet', 'Map');\n\nvar _default = function (_React$Component) {\n  _inherits(_default, _React$Component);\n\n  var _super = _createSuper(_default);\n\n  function _default(props) {\n    var _this;\n\n    _classCallCheck(this, _default);\n\n    _this = _super.call(this, props);\n\n    _this.animateToCoordinate = function (latLng, duration) {\n      _this.animateCamera({\n        center: latLng\n      }, duration);\n    };\n\n    _this.animateToBearing = function (bearing, duration) {\n      logger.warn('animateToBearing() is unsupported in Leaflet');\n    };\n\n    _this.animateToViewingAngle = function (angle, duration) {\n      logger.warn('animateToViewingAngle() is unsupported in Leaflet');\n    };\n\n    _this.ensureMarkers = function (markers) {\n      var output = [];\n      var markerIDs = [];\n\n      for (var _iterator = _createForOfIteratorHelperLoose(markers), _step; !(_step = _iterator()).done;) {\n        var marker = _step.value;\n\n        if (typeof marker === 'string') {\n          markerIDs.push(marker);\n        } else if (marker instanceof LeafletMarker) {\n          output.push(marker);\n        } else {\n          logger.warn('ensureMarkers', 'No valid marker for: ', marker);\n        }\n      }\n\n      return [].concat(_toConsumableArray(Object.values(_this.markersForIDs(markerIDs))), output);\n    };\n\n    _this.markersForIDs = function (markerIDs) {\n      var markers = {};\n\n      if (!markerIDs.length) {\n        return markers;\n      }\n\n      logger.log('markersForIDs', markerIDs);\n\n      _this.leafletElement.eachLayer(function (layer) {\n        if (layer instanceof LeafletMarker && markerIDs.includes(layer.options.id)) {\n          logger.log('markersForIDs', 'got marker', layer);\n          markers[layer.options.id] = layer;\n        }\n      });\n\n      return markers;\n    };\n\n    _this.fitToElements = function (animated) {\n      var ref = _this.leafletElement;\n      var features = [];\n      ref.eachLayer(function (layer) {\n        features.push(layer);\n      });\n\n      _this.fitToSuppliedMarkers(features, 0, animated);\n    };\n\n    _this.fitToSuppliedMarkers = function (markers, edgePadding, animated) {\n      var ensuredMarkers = _this.ensureMarkers(markers);\n\n      var coords = getCoordinatesForElements(ensuredMarkers);\n      logger.log('fitToSuppliedMarkers', 'markers', ensuredMarkers, coords);\n      return _this.fitToCoordinates(coords, edgePadding, animated);\n    };\n\n    _this.fitToCoordinates = function (coordinates, edgePadding, animated) {\n      if (edgePadding) {\n        logger.warn('fitToCoordinates() edgePadding is unimplemented');\n      }\n\n      var bounds = boundsForCooords(coordinates.map(function (coord) {\n        return convertCoordinate(coord);\n      }));\n\n      _this.leafletElement.flyToBounds(bounds, {\n        animate: animated,\n        duration: 0.5\n      });\n    };\n\n    _this.getMapBoundaries = function () {\n      var northEast = _this.leafletElement.getBounds().getNorthEast();\n\n      var southWest = _this.leafletElement.getBounds().getSouthWest();\n\n      return {\n        northEast: {\n          latitude: northEast.lat,\n          longitude: northEast.lng\n        },\n        southWest: {\n          latitude: southWest.lat,\n          longitude: southWest.lng\n        }\n      };\n    };\n\n    _this.setMapBoundaries = function (northEast, southWest) {\n      _this.leafletElement.fitBounds([convertCoordinate(northEast), convertCoordinate(southWest)]);\n    };\n\n    _this.pointForCoordinate = function (coordinate) {\n      return _this.leafletElement.latLngToContainerPoint(convertCoordinate(coordinate));\n    };\n\n    _this.coordinateForPoint = function (point) {\n      var ref = _this.leafletElement;\n      return ref.containerPointToLatLng(point);\n    };\n\n    _this.getMarkersFrames = function (onlyVisible) {};\n\n    _this.setCamera = function (camera) {\n      _this.animateCamera(camera, 0);\n    };\n\n    _this.getCamera = function () {\n      if (!_this.isReady) throw new Error('Leaflet.Map.getCamera(): map is not ready yet');\n\n      var _assertThisInitialize = _assertThisInitialized(_this),\n          leafletElement = _assertThisInitialize.leafletElement;\n\n      var center = leafletElement.getCenter();\n      return {\n        center: {\n          latitude: center.lat,\n          longitude: center.lng\n        },\n        zoom: leafletElement.getZoom()\n      };\n    };\n\n    _this.animateCamera = function (camera, duration) {\n      var ref = _this.leafletElement;\n      logger.log('animateCamera', ref, camera, duration);\n      var center = camera.center ? convertCoordinate(camera.center) : ref.getCenter();\n\n      if (typeof camera.heading === 'number') {\n        logger.warn('Camera heading is not supported in Leaflet');\n      }\n\n      if (typeof camera.pitch === 'number') {\n        logger.warn('Camera pitch is not supported in Leaflet');\n      }\n\n      ref.setView(center, camera.zoom || ref.getZoom(), {\n        animate: duration !== 0,\n        pan: {\n          duration: duration * 0.001\n        }\n      });\n    };\n\n    _this.animateToRegion = function (region, duration) {\n      var ref = _this.leafletElement;\n      var bounds = convertRegion(region);\n      logger.log('animateToRegion', ref, region, bounds, duration);\n      ref.flyToBounds(bounds, {\n        animate: duration !== 0,\n        duration: duration * 0.001\n      });\n    };\n\n    _this.setRef = function (ref) {\n      _this.ref = ref;\n    };\n\n    _this.nativeEventForPoint = function (_ref) {\n      var x = _ref.x,\n          y = _ref.y;\n\n      var coordinate = _this.leafletElement.layerPointToLatLng([x, y]);\n\n      return {\n        nativeEvent: {\n          position: {\n            x: x,\n            y: y\n          },\n          coordinate: {\n            latitude: coordinate.lat,\n            longitude: coordinate.lng\n          }\n        }\n      };\n    };\n\n    _this.onClick = function (event) {\n      if (_this.props.onPress) {\n        logger.log('onClick', event);\n\n        _this.props.onPress({\n          nativeEvent: {\n            coordinate: {\n              latitude: event.latlng.lat,\n              longitude: event.latlng.lng\n            }\n          }\n        });\n      }\n    };\n\n    _this.onViewportChange = function (_ref2) {\n      var originalEvent = _ref2.originalEvent;\n      if (!_this.isReady) return;\n\n      if (_this.props.onRegionChange) {\n        var region = boundsToRegion(_this.leafletElement.getBounds());\n        logger.log('onViewportChange', originalEvent, region);\n\n        _this.props.onRegionChange(region);\n      }\n\n      if (originalEvent && _this.props.onPanDrag) {\n        var x = originalEvent.layerX,\n            y = originalEvent.layerY;\n        logger.log('onPanDrag');\n\n        _this.props.onPanDrag(_this.nativeEventForPoint({\n          x: x,\n          y: y\n        }));\n      }\n    };\n\n    _this.onViewportChanged = function () {\n      if (!_this.isReady) return;\n\n      if (_this.props.onRegionChangeComplete) {\n        var region = boundsToRegion(_this.leafletElement.getBounds());\n        logger.log('onViewportChanged', event, region);\n\n        _this.props.onRegionChangeComplete(region);\n      }\n    };\n\n    _this.onReady = function () {\n      if (_this._initialCamera) {\n        _this.animateCamera(_this._initialCamera, 0);\n      } else if (_this._initialRegion) {\n        _this.leafletElement.fitBounds(convertRegion(_this._initialRegion));\n      }\n\n      _this._initialCamera = null;\n      _this._initialRegion = null;\n\n      _this.leafletElement.on('move', _this.onViewportChange);\n\n      if (_this.props.onMapReady) {\n        _this.props.onMapReady();\n      }\n    };\n\n    _this.findUser = function () {\n      _this.leafletElement.locate();\n    };\n\n    _this.handleLocationFound = function (_ref3) {\n      var latlng = _ref3.latlng;\n    };\n\n    _this._initialRegion = props.initialRegion;\n    _this._initialCamera = props.initialCamera;\n    return _this;\n  }\n\n  _createClass(_default, [{\n    key: \"setNativeProps\",\n    value: function setNativeProps(_ref4) {\n      var initialRegion = _ref4.initialRegion,\n          props = _objectWithoutProperties(_ref4, _excluded);\n\n      if (initialRegion !== undefined) {\n        if (this._initialRegion) {\n          this._initialRegion = initialRegion;\n        } else if (initialRegion) {\n          this.leafletElement.fitBounds(convertRegion(initialRegion));\n        }\n      } else {\n        logger.unsupported(props);\n      }\n    }\n  }, {\n    key: \"isReady\",\n    get: function get() {\n      return this.ref && this.ref.ref && this.ref.ref.leafletElement;\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.leafletElement.off('move', this.onViewportChange);\n    }\n  }, {\n    key: \"leafletElement\",\n    get: function get() {\n      if (!this.isReady) throw new Error('Cannot perform operation before the component has finished rendering.');\n      return this.ref.ref.leafletElement;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          children = _this$props.children,\n          mapPadding = _this$props.mapPadding,\n          region = _this$props.region,\n          camera = _this$props.camera,\n          scrollEnabled = _this$props.scrollEnabled,\n          zoomEnabled = _this$props.zoomEnabled,\n          zoomTapEnabled = _this$props.zoomTapEnabled,\n          zoomControlEnabled = _this$props.zoomControlEnabled,\n          minZoomLevel = _this$props.minZoomLevel,\n          maxZoomLevel = _this$props.maxZoomLevel,\n          style = _this$props.style,\n          onPress = _this$props.onPress;\n      logger.log('render', this.props);\n      var customOptions = {};\n\n      if ('mapPadding' in this.props) {\n        var boundsOptions = paddingToBoundOptions(mapPadding);\n        if (boundsOptions) customOptions.boundsOptions = boundsOptions;\n      }\n\n      var transformProps;\n\n      if (this._initialCamera || this._initialRegion) {\n        transformProps = transformPropsFromCamera({\n          camera: this._initialCamera,\n          region: this._initialRegion\n        });\n      } else if (camera || region) {\n        transformProps = transformPropsFromCamera({\n          camera: camera,\n          region: region\n        });\n      }\n\n      if (!transformProps) {\n        if (this.isReady) {\n          transformProps = {\n            zoom: this.leafletElement.getZoom(),\n            center: this.leafletElement.getCenter()\n          };\n        } else {\n          transformProps = {\n            zoom: DEFAULT_ZOOM,\n            center: DEFAULT_CENTER\n          };\n        }\n      }\n\n      var events = transformMapEvents(this.props);\n\n      if (this.props.customMapStyle) {\n        logger.warn('prop customMapStyle is not supported');\n      }\n\n      return React.createElement(LeafletMap, _extends({}, customOptions, transformProps, events, {\n        touchZoom: zoomEnabled,\n        scrollWheelZoom: zoomEnabled,\n        boxZoom: zoomEnabled,\n        keyboard: zoomEnabled,\n        doubleClickZoom: zoomTapEnabled,\n        zoomControl: zoomControlEnabled,\n        minZoom: minZoomLevel,\n        maxZoom: maxZoomLevel,\n        dragging: scrollEnabled,\n        whenReady: this.onReady,\n        onLocationfound: this.handleLocationFound,\n        onViewportChanged: this.onViewportChanged,\n        ref: this.setRef,\n        style: StyleSheet.flatten([{\n          zIndex: 0\n        }, style]),\n        url: \"https://unpkg.com/leaflet@1.5.1/dist/leaflet.css\"\n      }), React.createElement(TileLayer, {\n        attribution: ReactDOMServer.renderToString(React.createElement(Text, {\n          accessibilityRole: \"link\",\n          href: \"http://osm.org/copyright\",\n          style: {\n            fontSize: 11\n          }\n        }, \"OpenStreetMap\")),\n        url: \"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\n      }), children);\n    }\n  }]);\n\n  return _default;\n}(React.Component);\n\n_default.defaultProps = {\n  scrollEnabled: true,\n  zoomEnabled: true,\n  zoomTapEnabled: true,\n  zoomControlEnabled: true\n};\nexport { _default as default };\n\nfunction transformPropsFromCamera(_ref5) {\n  var camera = _ref5.camera,\n      region = _ref5.region;\n\n  if (camera) {\n    var transformProps = {\n      zoom: DEFAULT_ZOOM,\n      center: DEFAULT_CENTER\n    };\n\n    if ('center' in camera) {\n      transformProps.center = convertCoordinate(camera.center);\n    }\n\n    if ('heading' in camera) transformProps.heading = camera.heading;\n    if ('pitch' in camera) transformProps.pitch = camera.pitch;\n    if ('zoom' in camera) transformProps.zoom = camera.zoom;\n    if ('altitude' in camera) transformProps.altitude = camera.altitude;\n    return transformProps;\n  } else if (region) {\n    return {\n      bounds: convertRegion(region)\n    };\n  } else {\n    return undefined;\n  }\n}\n\nfunction paddingToBoundOptions(edgeInset) {\n  if (!edgeInset) return undefined;\n\n  if (typeof edgeInset === 'number') {\n    return {\n      padding: edgeInset\n    };\n  }\n\n  return {\n    paddingTopLeft: [edgeInset.top, edgeInset.left],\n    paddingBottomRight: [edgeInset.bottom, edgeInset.right]\n  };\n}","map":{"version":3,"sources":["/Users/kiraci/Desktop/improvement/petriam/frontend/petriam-frontend/node_modules/react-native-maps/lib/web/Leaflet/Map.js"],"names":["latLngBounds","boundsForCooords","Marker","LeafletMarker","React","Map","MapView","TileLayer","ReactDOMServer","createLogger","boundsToRegion","convertCoordinate","convertRegion","DEFAULT_CENTER","getCoordinatesForElements","withRemoteStyles","transformMapEvents","LeafletMap","DEFAULT_ZOOM","logger","props","animateToCoordinate","latLng","duration","animateCamera","center","animateToBearing","bearing","warn","animateToViewingAngle","angle","ensureMarkers","markers","output","markerIDs","marker","push","Object","values","markersForIDs","length","log","leafletElement","eachLayer","layer","includes","options","id","fitToElements","animated","ref","features","fitToSuppliedMarkers","edgePadding","ensuredMarkers","coords","fitToCoordinates","coordinates","bounds","map","coord","flyToBounds","animate","getMapBoundaries","northEast","getBounds","getNorthEast","southWest","getSouthWest","latitude","lat","longitude","lng","setMapBoundaries","fitBounds","pointForCoordinate","coordinate","latLngToContainerPoint","coordinateForPoint","point","containerPointToLatLng","getMarkersFrames","onlyVisible","setCamera","camera","getCamera","isReady","Error","getCenter","zoom","getZoom","heading","pitch","setView","pan","animateToRegion","region","setRef","nativeEventForPoint","x","y","layerPointToLatLng","nativeEvent","position","onClick","event","onPress","latlng","onViewportChange","originalEvent","onRegionChange","onPanDrag","layerX","layerY","onViewportChanged","onRegionChangeComplete","onReady","_initialCamera","_initialRegion","on","onMapReady","findUser","locate","handleLocationFound","initialRegion","initialCamera","undefined","unsupported","off","children","mapPadding","scrollEnabled","zoomEnabled","zoomTapEnabled","zoomControlEnabled","minZoomLevel","maxZoomLevel","style","customOptions","boundsOptions","paddingToBoundOptions","transformProps","transformPropsFromCamera","events","customMapStyle","StyleSheet","flatten","zIndex","renderToString","fontSize","Component","defaultProps","altitude","edgeInset","padding","paddingTopLeft","top","left","paddingBottomRight","bottom","right"],"mappings":"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","sourcesContent":["import { latLngBounds as boundsForCooords, Marker as LeafletMarker } from 'leaflet';\nimport * as React from 'react';\nimport { Map as MapView, TileLayer } from 'react-leaflet';\nimport { StyleSheet, Text } from 'react-native';\nimport ReactDOMServer from 'react-dom/server';\n\nimport createLogger from '../utils/createLogger';\nimport {\n  boundsToRegion,\n  convertCoordinate,\n  convertRegion,\n  DEFAULT_CENTER,\n  getCoordinatesForElements,\n} from './utils/coordinates';\nimport withRemoteStyles from './utils/withRemoteStyles';\nimport { transformMapEvents } from './utils/events';\n\nconst LeafletMap = withRemoteStyles(MapView);\nconst DEFAULT_ZOOM = 6;\nconst logger = createLogger('Leaflet', 'Map');\n\n// Leaflet map requires three default values. The TileLayer child, the center coordinate, and the zoom level.\n\nexport default class extends React.Component {\n  constructor(props) {\n    super(props);\n    this._initialRegion = props.initialRegion;\n    this._initialCamera = props.initialCamera;\n  }\n\n  setNativeProps({ initialRegion, ...props }) {\n    if (initialRegion !== undefined) {\n      if (this._initialRegion) {\n        this._initialRegion = initialRegion;\n      } else if (initialRegion) {\n        this.leafletElement.fitBounds(convertRegion(initialRegion));\n      }\n    } else {\n      logger.unsupported(props);\n    }\n  }\n\n  animateToCoordinate = (latLng, duration) => {\n    this.animateCamera({ center: latLng }, duration);\n  };\n\n  animateToBearing = (bearing, duration) => {\n    logger.warn('animateToBearing() is unsupported in Leaflet');\n  };\n\n  animateToViewingAngle = (angle, duration) => {\n    logger.warn('animateToViewingAngle() is unsupported in Leaflet');\n  };\n\n  ensureMarkers = markers => {\n    let output = [];\n\n    let markerIDs = [];\n    for (const marker of markers) {\n      if (typeof marker === 'string') {\n        markerIDs.push(marker);\n      } else if (marker instanceof LeafletMarker) {\n        output.push(marker);\n      } else {\n        logger.warn('ensureMarkers', 'No valid marker for: ', marker);\n      }\n    }\n\n    return [...Object.values(this.markersForIDs(markerIDs)), ...output];\n  };\n\n  markersForIDs = markerIDs => {\n    let markers = {};\n    if (!markerIDs.length) {\n      return markers;\n    }\n    logger.log('markersForIDs', markerIDs);\n    this.leafletElement.eachLayer(layer => {\n      if (layer instanceof LeafletMarker && markerIDs.includes(layer.options.id)) {\n        logger.log('markersForIDs', 'got marker', layer);\n        markers[layer.options.id] = layer;\n      }\n    });\n    return markers;\n  };\n\n  fitToElements = animated => {\n    const ref = this.leafletElement;\n    const features = [];\n    ref.eachLayer(layer => {\n      features.push(layer);\n    });\n    this.fitToSuppliedMarkers(features, 0, animated);\n  };\n\n  fitToSuppliedMarkers = (markers, edgePadding, animated) => {\n    const ensuredMarkers = this.ensureMarkers(markers);\n    const coords = getCoordinatesForElements(ensuredMarkers);\n    logger.log('fitToSuppliedMarkers', 'markers', ensuredMarkers, coords);\n    return this.fitToCoordinates(coords, edgePadding, animated);\n  };\n\n  fitToCoordinates = (coordinates, edgePadding, animated) => {\n    if (edgePadding) {\n      logger.warn('fitToCoordinates() edgePadding is unimplemented');\n    }\n    const bounds = boundsForCooords(coordinates.map(coord => convertCoordinate(coord)));\n    this.leafletElement.flyToBounds(bounds, {\n      animate: animated,\n      duration: 0.5,\n    });\n  };\n\n  getMapBoundaries = () => {\n    const northEast = this.leafletElement.getBounds().getNorthEast();\n    const southWest = this.leafletElement.getBounds().getSouthWest();\n    return {\n      northEast: {\n        latitude: northEast.lat,\n        longitude: northEast.lng,\n      },\n      southWest: {\n        latitude: southWest.lat,\n        longitude: southWest.lng,\n      },\n    };\n  };\n\n  setMapBoundaries = (northEast, southWest) => {\n    this.leafletElement.fitBounds([convertCoordinate(northEast), convertCoordinate(southWest)]);\n  };\n\n  // setIndoorActiveLevelIndex = (activeLevelIndex) => {\n  //   throw new Error('setIndoorActiveLevelIndex() is unsupported');\n  // }\n\n  // takeSnapshot = (width, height, region, format, quality, result, callback) => {\n  //   callback(new Error('takeSnapshot() is unsupported'), null);\n  // }\n\n  // animateToNavigation = (location, bearing, angle, duration) => {\n\n  // }\n\n  pointForCoordinate = coordinate => {\n    return this.leafletElement.latLngToContainerPoint(convertCoordinate(coordinate));\n  };\n\n  coordinateForPoint = point => {\n    const ref = this.leafletElement;\n    return ref.containerPointToLatLng(point);\n  };\n\n  getMarkersFrames = onlyVisible => {};\n\n  setCamera = camera => {\n    this.animateCamera(camera, 0);\n  };\n\n  getCamera = () => {\n    if (!this.isReady) throw new Error('Leaflet.Map.getCamera(): map is not ready yet');\n    const { leafletElement } = this;\n    const center = leafletElement.getCenter();\n    return {\n      center: {\n        latitude: center.lat,\n        longitude: center.lng,\n      },\n      zoom: leafletElement.getZoom(),\n    };\n  };\n\n  animateCamera = (camera, duration) => {\n    const ref = this.leafletElement;\n    logger.log('animateCamera', ref, camera, duration);\n\n    const center = camera.center ? convertCoordinate(camera.center) : ref.getCenter();\n\n    if (typeof camera.heading === 'number') {\n      logger.warn('Camera heading is not supported in Leaflet');\n    }\n    if (typeof camera.pitch === 'number') {\n      logger.warn('Camera pitch is not supported in Leaflet');\n    }\n\n    ref.setView(center, camera.zoom || ref.getZoom(), {\n      animate: duration !== 0,\n      pan: {\n        duration: duration * 0.001,\n      },\n    });\n  };\n\n  animateToRegion = (region, duration) => {\n    const ref = this.leafletElement;\n    const bounds = convertRegion(region);\n    logger.log('animateToRegion', ref, region, bounds, duration);\n    ref.flyToBounds(bounds, {\n      animate: duration !== 0,\n      duration: duration * 0.001,\n    });\n  };\n\n  setRef = ref => {\n    this.ref = ref;\n  };\n\n  nativeEventForPoint = ({ x, y }) => {\n    const coordinate = this.leafletElement.layerPointToLatLng([x, y]);\n    return {\n      nativeEvent: {\n        position: { x, y },\n        coordinate: {\n          latitude: coordinate.lat,\n          longitude: coordinate.lng,\n        },\n      },\n    };\n  };\n\n  onClick = event => {\n    if (this.props.onPress) {\n      logger.log('onClick', event);\n      this.props.onPress({\n        nativeEvent: {\n          coordinate: {\n            latitude: event.latlng.lat,\n            longitude: event.latlng.lng,\n          },\n        },\n      });\n    }\n  };\n\n  onViewportChange = ({ originalEvent }) => {\n    if (!this.isReady) return;\n\n    if (this.props.onRegionChange) {\n      const region = boundsToRegion(this.leafletElement.getBounds());\n      logger.log('onViewportChange', originalEvent, region);\n      this.props.onRegionChange(region);\n    }\n    if (originalEvent && this.props.onPanDrag) {\n      const { layerX: x, layerY: y } = originalEvent;\n      logger.log('onPanDrag');\n      this.props.onPanDrag(this.nativeEventForPoint({ x, y }));\n    }\n  };\n\n  onViewportChanged = () => {\n    if (!this.isReady) return;\n\n    if (this.props.onRegionChangeComplete) {\n      const region = boundsToRegion(this.leafletElement.getBounds());\n\n      logger.log('onViewportChanged', event, region);\n      this.props.onRegionChangeComplete(region);\n    }\n  };\n\n  onReady = () => {\n    if (this._initialCamera) {\n      this.animateCamera(this._initialCamera, 0);\n    } else if (this._initialRegion) {\n      this.leafletElement.fitBounds(convertRegion(this._initialRegion));\n    }\n    this._initialCamera = null;\n    this._initialRegion = null;\n    this.leafletElement.on('move', this.onViewportChange);\n    if (this.props.onMapReady) {\n      this.props.onMapReady();\n    }\n  };\n\n  get isReady() {\n    return this.ref && this.ref.ref && this.ref.ref.leafletElement;\n  }\n\n  componentWillUnmount() {\n    this.leafletElement.off('move', this.onViewportChange);\n  }\n\n  get leafletElement() {\n    if (!this.isReady)\n      throw new Error('Cannot perform operation before the component has finished rendering.');\n    return this.ref.ref.leafletElement;\n  }\n\n  /* \n  paddingAdjustmentBehavior\t'always'|'automatic'|'never'\t'never'\tIndicates how/when to affect padding with safe area insets (GoogleMaps in iOS only)\n  mapType\tString\t\"standard\"\tThe map type to be displayed. \n  - standard: standard road map (default)\n  - none: no map Note Not available on MapKit\n  - satellite: satellite view\n  - hybrid: satellite view with roads and points of interest overlayed\n  - terrain: (Android only) topographic view\n  - mutedStandard: more subtle, makes markers/lines pop more (iOS 11.0+ only)\n  customMapStyle\tArray\t\tAdds custom styling to the map component. See README for more information.\n  showsUserLocation\tBoolean\tfalse\tIf true the app will ask for the user's location. NOTE: You need to add NSLocationWhenInUseUsageDescription key in Info.plist to enable geolocation, otherwise it is going to fail silently! You will also need to add an explanation for why you need the users location against NSLocationWhenInUseUsageDescription in Info.plist. Otherwise Apple may reject your app submission.\n  userLocationAnnotationTitle\tString\t\tThe title of the annotation for current user location. This only works if showsUserLocation is true. There is a default value My Location set by MapView. Note: iOS only.\n  followsUserLocation\tBoolean\tfalse\tIf true the map will focus on the user's location. This only works if showsUserLocation is true and the user has shared their location. Note: iOS only.\n  showsMyLocationButton\tBoolean\ttrue\tIf false hide the button to move map to the current user's location.\n  showsPointsOfInterest\tBoolean\ttrue\tIf false points of interest won't be displayed on the map.\n  showsCompass\tBoolean\ttrue\tIf false compass won't be displayed on the map.\n  showsScale\tBoolean\ttrue\tA Boolean indicating whether the map shows scale information. Note: Apple Maps only.\n  showsBuildings\tBoolean\ttrue\tA Boolean indicating whether the map displays extruded building information.\n  showsTraffic\tBoolean\ttrue\tA Boolean value indicating whether the map displays traffic information.\n  showsIndoors\tBoolean\ttrue\tA Boolean indicating whether indoor maps should be enabled.\n  showsIndoorLevelPicker\tBoolean\tfalse\tA Boolean indicating whether indoor level picker should be enabled. Note: Google Maps only (either Android or iOS with PROVIDER_GOOGLE).\n  rotateEnabled\tBoolean\ttrue\tIf false the user won't be able to pinch/rotate the map.\n  pitchEnabled\tBoolean\ttrue\tIf false the user won't be able to adjust the camera’s pitch angle.\n  \n  camera\tCamera\t\tThe camera view the map should display. If you use this, the region property is ignored.\n  initialCamera\tCamera\t\tLike initialRegion, use this prop instead of camera only if you don't want to control the viewport of the map besides the initial camera setting. Changing this prop after the component has mounted will not result in a region change. This is similar to the initialValue prop of a text input.\n  initialRegion\tRegion\t\tThe initial region to be displayed by the map. Use this prop instead of region only if you don't want to control the viewport of the map besides the initial region. Changing this prop after the component has mounted will not result in a region change. This is similar to the initialValue prop of a text input.\n  mapPadding\tEdgePadding\t\tAdds custom padding to each side of the map. Useful when map elements/markers are obscured. Note Google Maps only.\n  zoomEnabled\tBoolean\ttrue\tIf false the user won't be able to pinch/zoom the map.\n  zoomTapEnabled\tBoolean\ttrue\tIf false the user won't be able to double tap to zoom the map. Note: But it will greatly decrease delay of tap gesture recognition. Note: Google Maps on iOS only\n  zoomControlEnabled\tBoolean\ttrue\tIf false the zoom control at the bottom right of the map won't be visible Note: Android only.\n  minZoomLevel\tNumber\t0\tMinimum zoom value for the map, must be between 0 and 20\n  maxZoomLevel\tNumber\t20\tMaximum zoom value for the map, must be between 0 and 20\n  scrollEnabled\tBoolean\ttrue\tIf false the user won't be able to change the map region being displayed.\n\n  toolbarEnabled\tBoolean\ttrue\tAndroid only If false will hide 'Navigate' and 'Open in Maps' buttons on marker press\n  cacheEnabled\tBoolean\tfalse\tIf true map will be cached and displayed as an image instead of being interactable, for performance usage. Note: Apple Maps only\n  moveOnMarkerPress\tBoolean\ttrue\tAndroid only If false the map won't move when a marker is pressed.\n  kmlSrc\tstring\t\tThe URL from KML file. Note: Google Maps and Markers only (either Android or iOS with PROVIDER_GOOGLE).\n\n\n  legalLabelInsets\tEdgeInsets\t\tIf set, changes the position of the \"Legal\" label link from the OS default. Note: iOS only.\n  compassOffset\tPoint\t\tIf set, changes the position of the compass. Note: iOS Maps only.\n\n  loadingEnabled\tBoolean\tfalse\tIf true a loading indicator will show while the map is loading.\n  loadingIndicatorColor\tColor\t#606060\tSets loading indicator color, default to #606060.\n  loadingBackgroundColor\tColor\t#FFFFFF\tSets loading background color, default to #FFFFFF.\n */\n\n  /* \n  onKmlReady\tKmlContainer\tCallback that is called once the kml is fully loaded.\n  onUserLocationChange\t{ coordinate: Location }\tCallback that is called when the underlying map figures our users current location (coordinate also includes isFromMockProvider value for Android API 18 and above). Make sure showsUserLocation is set to true and that the provider is \"google\".\n  onPoiClick\t{ coordinate: LatLng, position: Point, placeId: string, name: string }\tCallback that is called when user click on a POI.\n  onLongPress\t{ coordinate: LatLng, position: Point }\tCallback that is called when user makes a \"long press\" somewhere on the map.\n  onMarkerPress\t\tCallback that is called when a marker on the map is tapped by the user.\n  onMarkerSelect\t\tCallback that is called when a marker on the map becomes selected. This will be called when the callout for that marker is about to be shown. Note: iOS only.\n  onMarkerDeselect\t\tCallback that is called when a marker on the map becomes deselected. This will be called when the callout for that marker is about to be hidden. Note: iOS only.\n  onCalloutPress\t\tCallback that is called when a callout is tapped by the user.\n  onMarkerDragStart\t{ coordinate: LatLng, position: Point }\tCallback that is called when the user initiates a drag on a marker (if it is draggable)\n  onMarkerDrag\t{ coordinate: LatLng, position: Point }\tCallback called continuously as a marker is dragged\n  onMarkerDragEnd\t{ coordinate: LatLng, position: Point }\tCallback that is called when a drag on a marker finishes. This is usually the point you will want to setState on the marker's coordinate again\n  onIndoorLevelActivated\tIndoorLevel\tCallback that is called when a level on indoor building is activated\n  onIndoorBuildingFocused  IndoorBuilding\tCallback that is called when a indoor building is focused/unfocused\n */\n\n  static defaultProps = {\n    scrollEnabled: true,\n    zoomEnabled: true,\n    zoomTapEnabled: true,\n    zoomControlEnabled: true,\n    // minZoomLevel, maxZoomLevel, style, onPress\n  };\n\n  findUser = () => {\n    // this.props.showsUserLocation\n    this.leafletElement.locate();\n  };\n\n  handleLocationFound = ({ latlng }) => {\n    // User location\n  };\n\n  render() {\n    const {\n      children,\n      mapPadding,\n      region,\n      camera,\n      scrollEnabled,\n      zoomEnabled,\n      zoomTapEnabled,\n      zoomControlEnabled,\n      minZoomLevel,\n      maxZoomLevel,\n      style,\n      onPress,\n    } = this.props;\n    // const center = convertCoordinate(initialRegion);\n    logger.log('render', this.props);\n\n    const customOptions = {};\n\n    if ('mapPadding' in this.props) {\n      const boundsOptions = paddingToBoundOptions(mapPadding);\n      if (boundsOptions) customOptions.boundsOptions = boundsOptions;\n    }\n\n    let transformProps;\n\n    if (this._initialCamera || this._initialRegion) {\n      transformProps = transformPropsFromCamera({\n        camera: this._initialCamera,\n        region: this._initialRegion,\n      });\n    } else if (camera || region) {\n      transformProps = transformPropsFromCamera({\n        camera,\n        region,\n      });\n    }\n\n    if (!transformProps) {\n      if (this.isReady) {\n        transformProps = {\n          zoom: this.leafletElement.getZoom(),\n          center: this.leafletElement.getCenter(),\n        };\n      } else {\n        transformProps = {\n          zoom: DEFAULT_ZOOM,\n          center: DEFAULT_CENTER,\n        };\n      }\n    }\n\n    const events = transformMapEvents(this.props);\n\n    if (this.props.customMapStyle) {\n      logger.warn('prop customMapStyle is not supported');\n    }\n    return (\n      <LeafletMap\n        {...customOptions}\n        {...transformProps}\n        {...events}\n        touchZoom={zoomEnabled}\n        scrollWheelZoom={zoomEnabled}\n        boxZoom={zoomEnabled}\n        keyboard={zoomEnabled}\n        doubleClickZoom={zoomTapEnabled}\n        zoomControl={zoomControlEnabled}\n        minZoom={minZoomLevel}\n        maxZoom={maxZoomLevel}\n        dragging={scrollEnabled}\n        whenReady={this.onReady}\n        onLocationfound={this.handleLocationFound}\n        onViewportChanged={this.onViewportChanged}\n        ref={this.setRef}\n        style={StyleSheet.flatten([{ zIndex: 0 }, style])}\n        url=\"https://unpkg.com/leaflet@1.5.1/dist/leaflet.css\">\n        <TileLayer\n          attribution={ReactDOMServer.renderToString(\n            <Text accessibilityRole=\"link\" href=\"http://osm.org/copyright\" style={{ fontSize: 11 }}>\n              OpenStreetMap\n            </Text>\n          )}\n          url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\n        />\n        {children}\n      </LeafletMap>\n    );\n  }\n}\n\nfunction transformPropsFromCamera({ camera, region }) {\n  if (camera) {\n    const transformProps = {\n      zoom: DEFAULT_ZOOM,\n      center: DEFAULT_CENTER,\n    };\n    if ('center' in camera) {\n      transformProps.center = convertCoordinate(camera.center);\n    }\n    if ('heading' in camera) transformProps.heading = camera.heading;\n    if ('pitch' in camera) transformProps.pitch = camera.pitch;\n    if ('zoom' in camera) transformProps.zoom = camera.zoom;\n    if ('altitude' in camera) transformProps.altitude = camera.altitude;\n    return transformProps;\n  } else if (region) {\n    return {\n      bounds: convertRegion(region),\n    };\n  } else {\n    return undefined;\n  }\n}\n\nfunction paddingToBoundOptions(edgeInset) {\n  if (!edgeInset) return undefined;\n\n  if (typeof edgeInset === 'number') {\n    return {\n      padding: edgeInset,\n    };\n  }\n\n  return {\n    paddingTopLeft: [edgeInset.top, edgeInset.left],\n    paddingBottomRight: [edgeInset.bottom, edgeInset.right],\n  };\n}\n"]},"metadata":{},"sourceType":"module"}