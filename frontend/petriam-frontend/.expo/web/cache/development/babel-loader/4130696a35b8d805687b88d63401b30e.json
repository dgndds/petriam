{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _excluded = [\"coordinate\"],\n    _excluded2 = [\"identifier\", \"reuseIdentifier\", \"title\", \"description\", \"testID\", \"image\", \"icon\", \"opacity\", \"coordinate\", \"draggable\", \"flat\", \"tracksViewChanges\", \"tracksInfoWindowChanges\", \"stopPropagation\", \"onSelect\", \"onDeselect\", \"onCalloutPress\", \"pinColor\"],\n    _excluded3 = [\"map\", \"layerContainer\", \"position\", \"anchor\"];\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport * as React from 'react';\nimport View from \"react-native-web/dist/exports/View\";\nimport RNImage from \"react-native-web/dist/exports/Image\";\nimport PixelRatio from \"react-native-web/dist/exports/PixelRatio\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport Text from \"react-native-web/dist/exports/Text\";\nimport { convertCoordinate } from \"./utils/coordinates\";\nimport { parseIconProps } from \"./utils/icons\";\nimport createLogger from \"../utils/createLogger\";\nimport { transformPathEvents } from \"./utils/events\";\nimport { createPortal } from 'react-dom';\nimport { DivIcon, marker, Marker as LeafletMarker } from 'leaflet';\nimport * as RL from 'react-leaflet';\nimport { MapLayer, Marker, Popup } from 'react-leaflet';\nimport { difference } from 'lodash';\nvar logger = createLogger('Leaflet', 'Marker');\n\nvar ExpoMarker = function (_React$Component) {\n  _inherits(ExpoMarker, _React$Component);\n\n  var _super = _createSuper(ExpoMarker);\n\n  function ExpoMarker(props) {\n    var _this;\n\n    _classCallCheck(this, ExpoMarker);\n\n    _this = _super.call(this, props);\n    _this.state = {\n      position: convertCoordinate(props.coordinate)\n    };\n    return _this;\n  }\n\n  _createClass(ExpoMarker, [{\n    key: \"showCallout\",\n    value: function showCallout() {\n      this.ref.leafletElement.openPopup();\n    }\n  }, {\n    key: \"hideCallout\",\n    value: function hideCallout() {\n      this.ref.leafletElement.closePopup();\n    }\n  }, {\n    key: \"setNativeProps\",\n    value: function setNativeProps(_ref) {\n      var coordinate = _ref.coordinate,\n          props = _objectWithoutProperties(_ref, _excluded);\n\n      if (coordinate) {\n        this.setState({\n          position: convertCoordinate(coordinate)\n        });\n      }\n\n      logger.unsupported(props);\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      if (nextProps.coordinate !== this.props.coordinate) {\n        this.setState({\n          position: convertCoordinate(nextProps.coordinate)\n        });\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$props = this.props,\n          identifier = _this$props.identifier,\n          reuseIdentifier = _this$props.reuseIdentifier,\n          title = _this$props.title,\n          description = _this$props.description,\n          testID = _this$props.testID,\n          image = _this$props.image,\n          icon = _this$props.icon,\n          opacity = _this$props.opacity,\n          coordinate = _this$props.coordinate,\n          draggable = _this$props.draggable,\n          flat = _this$props.flat,\n          tracksViewChanges = _this$props.tracksViewChanges,\n          tracksInfoWindowChanges = _this$props.tracksInfoWindowChanges,\n          stopPropagation = _this$props.stopPropagation,\n          onSelect = _this$props.onSelect,\n          onDeselect = _this$props.onDeselect,\n          onCalloutPress = _this$props.onCalloutPress,\n          pinColor = _this$props.pinColor,\n          props = _objectWithoutProperties(_this$props, _excluded2);\n\n      var markerTitle = description ? title + \"\\n\" + description : title;\n      var position = this.state.position;\n      var leafletIcon = parseIconProps(_objectSpread({\n        icon: icon,\n        image: image\n      }, props));\n\n      var markerProps = _objectSpread(_objectSpread(_objectSpread({}, props), transformPathEvents(props)), {}, {\n        id: identifier,\n        opacity: opacity,\n        draggable: draggable,\n        title: markerTitle,\n        position: position\n      });\n\n      var isCustom = false;\n\n      if (leafletIcon) {\n        isCustom = true;\n        markerProps.icon = leafletIcon;\n      }\n\n      if (!isCustom && props.children) {\n        React.Children.forEach(props.children, function (child, index) {\n          if (!isCustom && child.type.name !== 'MapCallout') {\n            isCustom = true;\n          }\n        });\n      }\n\n      if (isCustom) {\n        return React.createElement(ExpoDivIcon, _extends({\n          ref: function ref(_ref2) {\n            return _this2.ref = _ref2;\n          }\n        }, markerProps));\n      } else if (pinColor) {\n        return React.createElement(ExpoDivIcon, _extends({\n          ref: function ref(_ref3) {\n            return _this2.ref = _ref3;\n          }\n        }, markerProps), React.createElement(View, {\n          style: {\n            backgroundColor: pinColor,\n            width: '3rem',\n            height: '3rem',\n            display: 'block',\n            position: 'relative',\n            borderRadius: '3rem',\n            borderBottomEndRadius: 0,\n            transform: [{\n              rotate: '45deg'\n            }],\n            borderWidth: 1,\n            borderStyle: 'solid',\n            borderColor: '#fff'\n          }\n        }), markerProps.children, React.createElement(StandardCallout, {\n          title: title,\n          description: description\n        }));\n      }\n\n      return React.createElement(ExpoStandardIcon, _extends({\n        ref: function ref(_ref4) {\n          return _this2.ref = _ref4;\n        }\n      }, markerProps), markerProps.children, (title || description) && React.createElement(StandardCallout, {\n        title: title,\n        description: description\n      }));\n    }\n  }]);\n\n  return ExpoMarker;\n}(React.Component);\n\nexport { ExpoMarker as default };\n\nvar FullSizeImage = function (_React$Component2) {\n  _inherits(FullSizeImage, _React$Component2);\n\n  var _super2 = _createSuper(FullSizeImage);\n\n  function FullSizeImage() {\n    var _this3;\n\n    _classCallCheck(this, FullSizeImage);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this3 = _super2.call.apply(_super2, [this].concat(args));\n    _this3.state = {\n      size: {}\n    };\n    return _this3;\n  }\n\n  _createClass(FullSizeImage, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this4 = this;\n\n      var img = new Image();\n      img.src = this.props.source.uri ? this.props.source.uri : this.props.source;\n\n      img.onload = function () {\n        _this4.setState({\n          size: {\n            width: img.width / PixelRatio.get(),\n            height: img.height / PixelRatio.get()\n          }\n        });\n      };\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return React.createElement(RNImage, _extends({\n        testID: \"expo-maps-marker-full-size-image\"\n      }, this.props, {\n        style: [this.props.style, this.state.size]\n      }));\n    }\n  }]);\n\n  return FullSizeImage;\n}(React.Component);\n\nfunction StandardCallout(_ref5) {\n  var title = _ref5.title,\n      description = _ref5.description;\n  return React.createElement(Popup, null, React.createElement(View, null, title && React.createElement(Text, {\n    style: {\n      fontWeight: 'bold'\n    }\n  }, title), description && React.createElement(Text, null, description)));\n}\n\nExpoMarker.defaultProps = {\n  centerOffset: null,\n  calloutOffset: null,\n  anchor: [0.5, 1],\n  calloutAnchor: [0.5, 0],\n  stopPropagation: false,\n  draggable: false,\n  opacity: 1.0\n};\n\nvar ExpoCustomMarker = function (_MapLayer) {\n  _inherits(ExpoCustomMarker, _MapLayer);\n\n  var _super3 = _createSuper(ExpoCustomMarker);\n\n  function ExpoCustomMarker() {\n    var _this5;\n\n    _classCallCheck(this, ExpoCustomMarker);\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    _this5 = _super3.call.apply(_super3, [this].concat(args));\n\n    _this5.updateAnchor = function (anchor, element) {\n      if (!_this5.leafletElement.getElement()) return;\n\n      var iconAnchor = _this5.getRelativePointFromRect(anchor, element || _this5.leafletElement.getElement().getBoundingClientRect());\n\n      logger.log('toAnchor: ', iconAnchor, _this5.leafletElement.getElement().getBoundingClientRect());\n      _this5.icon.options.iconAnchor = iconAnchor;\n      _this5.leafletElement.getElement().style.marginLeft = -iconAnchor.x + 'px';\n      _this5.leafletElement.getElement().style.marginTop = -iconAnchor.y + 'px';\n    };\n\n    _this5.updateCalloutAnchor = function (anchor, element) {\n      if (!_this5.leafletElement.getElement()) return;\n      _this5.icon.options.popupAnchor = _this5.getPopupRelativePointFromRect(anchor, element || _this5.leafletElement.getElement().getBoundingClientRect());\n    };\n\n    _this5.getIconElement = function () {\n      var element = _this5.leafletElement.getElement();\n\n      if (!element) return null;\n      return element.querySelector('[data-testid=\"expo-maps-marker-full-size-image\"]');\n    };\n\n    _this5.getRectWithIcon = function () {\n      var container = _this5.rect;\n\n      var iconElement = _this5.getIconElement();\n\n      if (!iconElement) return _this5.rect;\n      var icon = iconElement.getBoundingClientRect();\n      var leftMost = Math.min(icon.x, container.x);\n      var rightMost = Math.max(icon.x + icon.width, container.x + container.width);\n      var topMost = Math.min(icon.y, container.y);\n      var bottomMost = Math.max(icon.y + icon.height, container.y + container.height);\n      return {\n        width: rightMost - leftMost,\n        height: bottomMost - topMost\n      };\n    };\n\n    _this5.onLayoutDidUpdate = function () {\n      var rect = _this5.getRectWithIcon();\n\n      _this5.updateAnchor(_this5.props.anchor, rect);\n\n      _this5.updateCalloutAnchor(_this5.props.calloutAnchor, rect);\n    };\n\n    _this5.observeElementLayout = function (element) {\n      var resizeObserver = new ResizeObserver(function () {\n        _this5.onLayoutDidUpdate();\n      }, element);\n      resizeObserver.observe(element);\n      return resizeObserver;\n    };\n\n    _this5.observeLayout = function (container) {\n      if (!_this5.resizeObserver) {\n        _this5.resizeObserver = _this5.observeElementLayout(container);\n      }\n\n      var image = container.querySelector('[data-testid=\"expo-maps-marker-full-size-image\"]');\n\n      if (image) {\n        _this5.observeElementLayout(image);\n      }\n    };\n\n    return _this5;\n  }\n\n  _createClass(ExpoCustomMarker, [{\n    key: \"createLeafletElement\",\n    value: function createLeafletElement(props) {\n      throw new Error('createLeafletElement should be overwritten');\n    }\n  }, {\n    key: \"getRelativePoint\",\n    value: function getRelativePoint(point) {\n      if (!point) return null;\n\n      var _ofPoint = ofPoint(point),\n          x = _ofPoint.x,\n          y = _ofPoint.y;\n\n      var _this$rect = this.rect,\n          width = _this$rect.width,\n          height = _this$rect.height;\n      return {\n        x: x * width,\n        y: y * height\n      };\n    }\n  }, {\n    key: \"getRelativePointFromRect\",\n    value: function getRelativePointFromRect(point, element) {\n      if (!point) return null;\n\n      var _ofPoint2 = ofPoint(point),\n          x = _ofPoint2.x,\n          y = _ofPoint2.y;\n\n      var width = element.width,\n          height = element.height;\n      return {\n        x: x * width,\n        y: y * height\n      };\n    }\n  }, {\n    key: \"getPopupRelativePointFromRect\",\n    value: function getPopupRelativePointFromRect(point, element) {\n      if (!point) return null;\n\n      var _ofPoint3 = ofPoint(point),\n          x = _ofPoint3.x,\n          y = _ofPoint3.y;\n\n      var width = element.width,\n          height = element.height;\n      return {\n        x: x * width - width / 2,\n        y: y * height - height\n      };\n    }\n  }, {\n    key: \"icon\",\n    get: function get() {\n      if (!this.leafletElement.options.icon) throw new Error('Leaflet.Marker: icon not loaded yet');\n      return this.leafletElement.options.icon;\n    }\n  }, {\n    key: \"rect\",\n    get: function get() {\n      var element = this.leafletElement.getElement();\n      if (!element) return {};\n      return element.getBoundingClientRect();\n    }\n  }, {\n    key: \"tryUpdatePopupAnchor\",\n    value: function tryUpdatePopupAnchor(anchor) {\n      var _this6 = this;\n\n      if (!anchor) return;\n      var element = this.leafletElement._popup;\n      clearTimeout(this._popupAnchorTimeout);\n      logger.log('Element', element._container);\n\n      if (!element._container) {\n        this._popupAnchorTimeout = setTimeout(function () {\n          return _this6.tryUpdatePopupAnchor(anchor);\n        }, 300);\n      } else {\n        this.updatePopupAnchor(anchor, element._container);\n      }\n    }\n  }, {\n    key: \"updatePopupAnchor\",\n    value: function updatePopupAnchor(anchor, element) {\n      if (!element) return;\n      var rect = element.getBoundingClientRect();\n\n      var _ofPoint4 = ofPoint(anchor),\n          x = _ofPoint4.x,\n          y = _ofPoint4.y;\n\n      var containerRect = this.rect;\n      var height = rect.height;\n      var computedStyle = window.getComputedStyle(element);\n      var outerHeight = 0;\n      outerHeight += parseInt(computedStyle.marginTop, 10);\n      outerHeight += parseInt(computedStyle.marginBottom, 10);\n      outerHeight += parseInt(computedStyle.borderTopWidth, 10);\n      outerHeight += parseInt(computedStyle.borderBottomWidth, 10);\n      outerHeight *= 0.5;\n      outerHeight += height;\n      var popupAnchor = {\n        x: containerRect.width * -0.5 + containerRect.width * x,\n        y: (y - 1) * outerHeight\n      };\n      this.icon.options.popupAnchor = popupAnchor;\n    }\n  }, {\n    key: \"updateLeafletElement\",\n    value: function updateLeafletElement(fromProps, toProps) {\n      var fromPosition = fromProps.position,\n          fromZIndexOffset = fromProps.zIndexOffset,\n          fromOpacity = fromProps.opacity,\n          fromDraggable = fromProps.draggable,\n          fromClassName = fromProps.className,\n          fromAnchor = fromProps.anchor,\n          fromCalloutAnchor = fromProps.calloutAnchor;\n      var toPosition = toProps.position,\n          toZIndexOffset = toProps.zIndexOffset,\n          toOpacity = toProps.toOpacity,\n          toDraggable = toProps.draggable,\n          toClassName = toProps.className,\n          toAnchor = toProps.anchor,\n          toCalloutAnchor = toProps.calloutAnchor;\n      var rect;\n\n      if (toAnchor !== fromAnchor) {\n        if (!rect) rect = this.getRectWithIcon();\n        this.updateAnchor(toAnchor, rect);\n      }\n\n      if (toCalloutAnchor !== fromCalloutAnchor) {\n        if (!rect) rect = this.getRectWithIcon();\n        this.updateCalloutAnchor(toCalloutAnchor, rect);\n      }\n\n      if (toPosition !== fromPosition) {\n        this.leafletElement.setLatLng(toPosition);\n      }\n\n      if (toZIndexOffset !== fromZIndexOffset) {\n        this.leafletElement.setZIndexOffset(toZIndexOffset);\n      }\n\n      if (toOpacity !== fromOpacity) {\n        this.leafletElement.setOpacity(toOpacity);\n      }\n\n      if (toProps.icon !== fromProps.icon) {\n        this.observeLayout(this.leafletElement.getElement());\n      }\n\n      if (toDraggable !== fromDraggable) {\n        if (toDraggable) {\n          this.leafletElement.dragging.enable();\n        } else {\n          this.leafletElement.dragging.disable();\n        }\n      }\n\n      if (toClassName !== fromClassName) {\n        var _this$leafletElement$, _this$leafletElement$2;\n\n        var fromClasses = fromClassName.split(' ');\n        var toClasses = toClassName.split(' ');\n\n        (_this$leafletElement$ = this.leafletElement.getElement().classList).remove.apply(_this$leafletElement$, _toConsumableArray(difference(fromClasses, toClasses)));\n\n        (_this$leafletElement$2 = this.leafletElement.getElement().classList).add.apply(_this$leafletElement$2, _toConsumableArray(difference(toClasses, fromClasses)));\n      }\n    }\n  }, {\n    key: \"componentWillMount\",\n    value: function componentWillMount() {\n      var _this7 = this;\n\n      if (_get(_getPrototypeOf(ExpoCustomMarker.prototype), \"componentWillMount\", this)) {\n        _get(_getPrototypeOf(ExpoCustomMarker.prototype), \"componentWillMount\", this).call(this);\n      }\n\n      this.leafletElement = this.createLeafletElement(this.props);\n      this.leafletElement.on('add', function () {\n        _this7.forceUpdate(function () {\n          _this7.updateLeafletElement({}, _this7.props);\n\n          _this7.observeLayout(_this7.leafletElement.getElement());\n        });\n      });\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(fromProps) {\n      this.updateLeafletElement(fromProps, this.props);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      throw new Error('render should be overwritten');\n    }\n  }]);\n\n  return ExpoCustomMarker;\n}(MapLayer);\n\nvar ReactDivIcon = function (_ExpoCustomMarker) {\n  _inherits(ReactDivIcon, _ExpoCustomMarker);\n\n  var _super4 = _createSuper(ReactDivIcon);\n\n  function ReactDivIcon() {\n    _classCallCheck(this, ReactDivIcon);\n\n    return _super4.apply(this, arguments);\n  }\n\n  _createClass(ReactDivIcon, [{\n    key: \"createLeafletElement\",\n    value: function createLeafletElement(props) {\n      var map = props.map,\n          layerContainer = props.layerContainer,\n          position = props.position,\n          anchor = props.anchor,\n          rest = _objectWithoutProperties(props, _excluded3);\n\n      var icon = new DivIcon(_objectSpread(_objectSpread({}, rest), {}, {\n        className: '',\n        iconSize: undefined\n      }));\n      var options = this.getOptions(props);\n      var popupContainer = marker(position, _objectSpread(_objectSpread({}, options), {}, {\n        icon: icon\n      }));\n      this.contextValue = _objectSpread(_objectSpread({}, props.leaflet), {}, {\n        popupContainer: popupContainer\n      });\n      return popupContainer;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props2 = this.props,\n          children = _this$props2.children,\n          icon = _this$props2.icon;\n      var container = this.leafletElement.getElement();\n\n      if (!container) {\n        return null;\n      }\n\n      this.portal = createPortal(React.createElement(View, null, icon && React.createElement(FullSizeImage, {\n        style: [StyleSheet.absoluteFill, {\n          zIndex: -1\n        }],\n        source: {\n          uri: icon.options.iconUrl\n        }\n      }), children), container);\n      var LeafletProvider = RL.LeafletProvider;\n      return this.portal == null || this.contextValue == null ? null : React.createElement(LeafletProvider, {\n        value: this.contextValue\n      }, this.portal);\n    }\n  }]);\n\n  return ReactDivIcon;\n}(ExpoCustomMarker);\n\nvar ReactMarker = function (_ExpoCustomMarker2) {\n  _inherits(ReactMarker, _ExpoCustomMarker2);\n\n  var _super5 = _createSuper(ReactMarker);\n\n  function ReactMarker() {\n    _classCallCheck(this, ReactMarker);\n\n    return _super5.apply(this, arguments);\n  }\n\n  _createClass(ReactMarker, [{\n    key: \"createLeafletElement\",\n    value: function createLeafletElement(props) {\n      var el = new LeafletMarker(props.position, this.getOptions(props));\n      this.contextValue = _objectSpread(_objectSpread({}, props.leaflet), {}, {\n        popupContainer: el\n      });\n      return el;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var children = this.props.children;\n      var LeafletProvider = RL.LeafletProvider;\n      var container = this.leafletElement.getElement();\n\n      if (!container) {\n        return null;\n      }\n\n      return children == null || this.contextValue == null ? null : React.createElement(LeafletProvider, {\n        value: this.contextValue\n      }, children);\n    }\n  }]);\n\n  return ReactMarker;\n}(ExpoCustomMarker);\n\nvar ExpoStandardIcon = RL.withLeaflet(ReactMarker);\nvar ExpoDivIcon = RL.withLeaflet(ReactDivIcon);\n\nfunction ofPoint(point) {\n  if (!point) return;\n\n  if (Array.isArray(point) && point.length === 2) {\n    return {\n      x: point[0],\n      y: point[1]\n    };\n  }\n\n  if (point.x !== undefined && point.y !== undefined) {\n    return {\n      x: point.x,\n      y: point.y\n    };\n  }\n\n  throw new Error('Leaflet.Marker: Point is unexpected type: ' + point);\n}","map":{"version":3,"sources":["/Users/kiraci/Desktop/improvement/petriam/frontend/petriam-frontend/node_modules/react-native-maps/lib/web/Leaflet/Marker.js"],"names":["React","convertCoordinate","parseIconProps","createLogger","transformPathEvents","createPortal","DivIcon","marker","Marker","LeafletMarker","RL","MapLayer","Popup","difference","logger","ExpoMarker","props","state","position","coordinate","ref","leafletElement","openPopup","closePopup","setState","unsupported","nextProps","identifier","reuseIdentifier","title","description","testID","image","icon","opacity","draggable","flat","tracksViewChanges","tracksInfoWindowChanges","stopPropagation","onSelect","onDeselect","onCalloutPress","pinColor","markerTitle","leafletIcon","markerProps","id","isCustom","children","Children","forEach","child","index","type","name","backgroundColor","width","height","display","borderRadius","borderBottomEndRadius","transform","rotate","borderWidth","borderStyle","borderColor","Component","FullSizeImage","size","img","Image","src","source","uri","onload","PixelRatio","get","style","StandardCallout","fontWeight","defaultProps","centerOffset","calloutOffset","anchor","calloutAnchor","ExpoCustomMarker","updateAnchor","element","getElement","iconAnchor","getRelativePointFromRect","getBoundingClientRect","log","options","marginLeft","x","marginTop","y","updateCalloutAnchor","popupAnchor","getPopupRelativePointFromRect","getIconElement","querySelector","getRectWithIcon","container","rect","iconElement","leftMost","Math","min","rightMost","max","topMost","bottomMost","onLayoutDidUpdate","observeElementLayout","resizeObserver","ResizeObserver","observe","observeLayout","Error","point","ofPoint","_popup","clearTimeout","_popupAnchorTimeout","_container","setTimeout","tryUpdatePopupAnchor","updatePopupAnchor","containerRect","computedStyle","window","getComputedStyle","outerHeight","parseInt","marginBottom","borderTopWidth","borderBottomWidth","fromProps","toProps","fromPosition","fromZIndexOffset","zIndexOffset","fromOpacity","fromDraggable","fromClassName","className","fromAnchor","fromCalloutAnchor","toPosition","toZIndexOffset","toOpacity","toDraggable","toClassName","toAnchor","toCalloutAnchor","setLatLng","setZIndexOffset","setOpacity","dragging","enable","disable","fromClasses","split","toClasses","classList","remove","add","createLeafletElement","on","forceUpdate","updateLeafletElement","ReactDivIcon","map","layerContainer","rest","iconSize","undefined","getOptions","popupContainer","contextValue","leaflet","portal","StyleSheet","absoluteFill","zIndex","iconUrl","LeafletProvider","ReactMarker","el","ExpoStandardIcon","withLeaflet","ExpoDivIcon","Array","isArray","length"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { View, Image as RNImage, PixelRatio, StyleSheet, Text } from 'react-native';\nimport { convertCoordinate } from './utils/coordinates';\nimport { parseIconProps } from './utils/icons';\nimport createLogger from '../utils/createLogger';\nimport { transformPathEvents } from './utils/events';\n// Missing:\n// zIndexOffset\n// attribution\n\nimport { createPortal } from 'react-dom';\nimport { DivIcon, marker, Marker as LeafletMarker } from 'leaflet';\n\nimport * as RL from 'react-leaflet';\nimport { MapLayer, Marker, Popup } from 'react-leaflet';\nimport { difference } from 'lodash';\n\nconst logger = createLogger('Leaflet', 'Marker');\n\nexport default class ExpoMarker extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      position: convertCoordinate(props.coordinate),\n    };\n  }\n  // Shows the callout for this marker\n  showCallout() {\n    this.ref.leafletElement.openPopup();\n  }\n  // Hides the callout for this marker\n  hideCallout() {\n    this.ref.leafletElement.closePopup();\n  }\n  // // Causes a redraw of the marker's callout. Useful for Google Maps on iOS.\n  // // Note: iOS only.\n  // redrawCallout() {\n  //   logger.warn('redrawCallout() is unsupported');\n  // }\n  // // Animates marker movement.\n  // // Note: Android only\n  // animateMarkerToCoordinate(coordinate, duration) {\n  //   logger.warn('animateMarkerToCoordinate(coordinate, duration) is unsupported');\n  // }\n  // // Causes a redraw of the marker. Useful when there are updates to the marker and tracksViewChanges comes with a cost that is too high.\n  // redraw() {\n  //   logger.warn('redraw() is unsupported');\n  // }\n\n  setNativeProps({ coordinate, ...props }) {\n    if (coordinate) {\n      this.setState({ position: convertCoordinate(coordinate) });\n    }\n    logger.unsupported(props);\n  }\n\n  componentWillReceiveProps(nextProps) {\n    if (nextProps.coordinate !== this.props.coordinate) {\n      this.setState({ position: convertCoordinate(nextProps.coordinate) });\n    }\n  }\n\n  render() {\n    const {\n      identifier,\n      reuseIdentifier,\n      title,\n      description,\n      testID,\n      image,\n      icon,\n      opacity,\n      coordinate,\n      draggable,\n      flat,\n      tracksViewChanges,\n      tracksInfoWindowChanges,\n      stopPropagation,\n      onSelect,\n      onDeselect,\n      onCalloutPress,\n      pinColor,\n      ...props\n    } = this.props;\n    const markerTitle = description ? `${title}\\n${description}` : title;\n    const { position } = this.state;\n    let leafletIcon = parseIconProps({ icon, image, ...props }); // TODO:\n\n    const markerProps = {\n      ...props,\n      ...transformPathEvents(props),\n      id: identifier,\n      opacity,\n      draggable,\n      title: markerTitle,\n      position,\n    };\n\n    let isCustom = false;\n\n    if (leafletIcon) {\n      isCustom = true;\n      markerProps.icon = leafletIcon;\n    }\n\n    if (!isCustom && props.children) {\n      React.Children.forEach(props.children, (child, index) => {\n        if (!isCustom && child.type.name !== 'MapCallout') {\n          isCustom = true;\n        }\n      });\n    }\n\n    if (isCustom) {\n      return <ExpoDivIcon ref={ref => (this.ref = ref)} {...markerProps} />;\n    } else if (pinColor) {\n      return (\n        <ExpoDivIcon ref={ref => (this.ref = ref)} {...markerProps}>\n          <View\n            style={{\n              backgroundColor: pinColor,\n              width: '3rem',\n              height: '3rem',\n              display: 'block',\n              position: 'relative',\n              borderRadius: '3rem',\n              borderBottomEndRadius: 0,\n              transform: [{ rotate: '45deg' }],\n              borderWidth: 1,\n              borderStyle: 'solid',\n              borderColor: '#fff',\n            }}\n          />\n          {markerProps.children}\n          <StandardCallout title={title} description={description} />\n        </ExpoDivIcon>\n      );\n    }\n\n    return (\n      <ExpoStandardIcon ref={ref => (this.ref = ref)} {...markerProps}>\n        {markerProps.children}\n        {(title || description) && <StandardCallout title={title} description={description} />}\n      </ExpoStandardIcon>\n    );\n  }\n}\n\nclass FullSizeImage extends React.Component {\n  state = {\n    size: {},\n  };\n\n  componentDidMount() {\n    const img = new Image();\n    img.src = this.props.source.uri ? this.props.source.uri : this.props.source;\n    img.onload = () => {\n      this.setState({\n        size: {\n          width: img.width / PixelRatio.get(),\n          height: img.height / PixelRatio.get(),\n        },\n      });\n    };\n  }\n  render() {\n    return (\n      <RNImage\n        testID=\"expo-maps-marker-full-size-image\"\n        {...this.props}\n        style={[this.props.style, this.state.size]}\n      />\n    );\n  }\n}\n\n// function FullSizeImage({ source, ...props }) {\n//   const [size, setSize] = React.useState({});\n\n//   React.useEffect(() => {\n//     const img = new HTMLImageElement();\n//     img.src = source.uri ? source.uri : source;\n//     img.onload = () => {\n//       setSize({\n//         width: img.width,\n//         height: img.height,\n//       });\n//     };\n//     return () => (img = null);\n//   }, [source]);\n\n//   return <Image {...props} style={[props.style, size]} />;\n// }\n\nfunction StandardCallout({ title, description }) {\n  return (\n    <Popup>\n      <View>\n        {title && <Text style={{ fontWeight: 'bold' }}>{title}</Text>}\n        {description && <Text>{description}</Text>}\n      </View>\n    </Popup>\n  );\n}\n\nExpoMarker.defaultProps = {\n  centerOffset: /** Unused: use `anchor` instead */ null,\n  calloutOffset: /** Unused: use `calloutAnchor` instead */ null,\n  anchor: /** Leeaflet: `iconAnchor` */ [0.5, 1],\n  calloutAnchor: /** Leaflet: `popupAnchor` */ [0.5, 0],\n  // flat: /** Unsupported */ false,\n  // rotation: /** Unsupported */ 0,\n  // tracksViewChanges: /** Unused */ true,\n  // tracksInfoWindowChanges: /** Unused */ false,\n  stopPropagation: /** Unimplemented */ false,\n  draggable: false,\n  opacity: 1.0,\n};\n\n// TODO(Bacon): Update the anchor when the layout changes\n// https://stackoverflow.com/questions/47018368/implementing-a-dynamic-jsx-element-within-a-marker-using-react-leaflet/54504646#54504646\nclass ExpoCustomMarker extends MapLayer {\n  createLeafletElement(props) {\n    throw new Error('createLeafletElement should be overwritten');\n  }\n\n  getRelativePoint(point) {\n    if (!point) return null;\n    const { x, y } = ofPoint(point);\n    const { width, height } = this.rect;\n    return { x: x * width, y: y * height };\n  }\n\n  getRelativePointFromRect(point, element) {\n    if (!point) return null;\n    const { x, y } = ofPoint(point);\n    const { width, height } = element;\n    return { x: x * width, y: y * height };\n  }\n\n  getPopupRelativePointFromRect(point, element) {\n    if (!point) return null;\n    const { x, y } = ofPoint(point);\n    const { width, height } = element;\n    return { x: x * width - width / 2, y: y * height - height };\n  }\n\n  get icon() {\n    if (!this.leafletElement.options.icon) throw new Error('Leaflet.Marker: icon not loaded yet');\n\n    return this.leafletElement.options.icon;\n  }\n\n  get rect() {\n    const element = this.leafletElement.getElement();\n    if (!element) return {};\n    return element.getBoundingClientRect();\n  }\n\n  tryUpdatePopupAnchor(anchor) {\n    if (!anchor) return;\n\n    const element = this.leafletElement._popup;\n\n    clearTimeout(this._popupAnchorTimeout);\n    logger.log('Element', element._container);\n    if (!element._container) {\n      this._popupAnchorTimeout = setTimeout(() => this.tryUpdatePopupAnchor(anchor), 300);\n    } else {\n      this.updatePopupAnchor(anchor, element._container);\n    }\n  }\n\n  updatePopupAnchor(anchor, element) {\n    if (!element) return;\n\n    const rect = element.getBoundingClientRect();\n    const { x, y } = ofPoint(anchor);\n    const containerRect = this.rect;\n    const { height } = rect;\n\n    const computedStyle = window.getComputedStyle(element);\n    let outerHeight = 0;\n    outerHeight += parseInt(computedStyle.marginTop, 10);\n    outerHeight += parseInt(computedStyle.marginBottom, 10);\n    outerHeight += parseInt(computedStyle.borderTopWidth, 10);\n    outerHeight += parseInt(computedStyle.borderBottomWidth, 10);\n    outerHeight *= 0.5;\n    outerHeight += height;\n\n    const popupAnchor = {\n      x: containerRect.width * -0.5 + containerRect.width * x,\n      y: (y - 1) * outerHeight,\n    };\n\n    // logger.log('RECT: ', rect, element, element.style, outerHeight, popupAnchor);\n    // Update the option for internal usage\n    this.icon.options.popupAnchor = popupAnchor;\n  }\n\n  updateAnchor = (anchor, element) => {\n    if (!this.leafletElement.getElement()) return;\n    // Convert to a unified format\n    const iconAnchor = this.getRelativePointFromRect(\n      anchor,\n      element || this.leafletElement.getElement().getBoundingClientRect()\n    );\n    logger.log('toAnchor: ', iconAnchor, this.leafletElement.getElement().getBoundingClientRect());\n    // Update the option for internal usage\n    this.icon.options.iconAnchor = iconAnchor;\n    // Manually redefine the styles\n    this.leafletElement.getElement().style.marginLeft = -iconAnchor.x + 'px';\n    this.leafletElement.getElement().style.marginTop = -iconAnchor.y + 'px';\n  };\n\n  updateCalloutAnchor = (anchor, element) => {\n    if (!this.leafletElement.getElement()) return;\n    // TODO(Bacon): Experimental: this feature requires the callout to be rendered before it can correctly position the element.\n    // this.tryUpdatePopupAnchor(anchor);\n    this.icon.options.popupAnchor = this.getPopupRelativePointFromRect(\n      anchor,\n      element || this.leafletElement.getElement().getBoundingClientRect()\n    );\n  };\n\n  updateLeafletElement(fromProps, toProps) {\n    const {\n      position: fromPosition,\n      zIndexOffset: fromZIndexOffset,\n      opacity: fromOpacity,\n      draggable: fromDraggable,\n      className: fromClassName,\n      anchor: fromAnchor,\n      calloutAnchor: fromCalloutAnchor,\n    } = fromProps;\n    const {\n      position: toPosition,\n      zIndexOffset: toZIndexOffset,\n      toOpacity,\n      draggable: toDraggable,\n      className: toClassName,\n      anchor: toAnchor,\n      calloutAnchor: toCalloutAnchor,\n    } = toProps;\n\n    // this.icon.options.iconSize = [this.rect.width, this.rect.height];\n\n    let rect;\n    if (toAnchor !== fromAnchor) {\n      if (!rect) rect = this.getRectWithIcon();\n      this.updateAnchor(toAnchor, rect);\n    }\n\n    if (toCalloutAnchor !== fromCalloutAnchor) {\n      if (!rect) rect = this.getRectWithIcon();\n      this.updateCalloutAnchor(toCalloutAnchor, rect);\n    }\n\n    if (toPosition !== fromPosition) {\n      this.leafletElement.setLatLng(toPosition);\n    }\n    if (toZIndexOffset !== fromZIndexOffset) {\n      this.leafletElement.setZIndexOffset(toZIndexOffset);\n    }\n    if (toOpacity !== fromOpacity) {\n      this.leafletElement.setOpacity(toOpacity);\n    }\n    if (toProps.icon !== fromProps.icon) {\n      // this.leafletElement.setIcon(toProps.icon);\n      this.observeLayout(this.leafletElement.getElement());\n    }\n    if (toDraggable !== fromDraggable) {\n      if (toDraggable) {\n        this.leafletElement.dragging.enable();\n      } else {\n        this.leafletElement.dragging.disable();\n      }\n    }\n    if (toClassName !== fromClassName) {\n      const fromClasses = fromClassName.split(' ');\n      const toClasses = toClassName.split(' ');\n      this.leafletElement.getElement().classList.remove(...difference(fromClasses, toClasses));\n      this.leafletElement.getElement().classList.add(...difference(toClasses, fromClasses));\n    }\n  }\n\n  componentWillMount() {\n    if (super.componentWillMount) {\n      super.componentWillMount();\n    }\n    this.leafletElement = this.createLeafletElement(this.props);\n    this.leafletElement.on('add', () => {\n      this.forceUpdate(() => {\n        // Wait until the React elements have rendered before setting things like anchor which require the bounding rect.\n        this.updateLeafletElement({}, this.props);\n        this.observeLayout(this.leafletElement.getElement());\n      });\n    });\n  }\n\n  componentDidUpdate(fromProps) {\n    this.updateLeafletElement(fromProps, this.props);\n  }\n\n  getIconElement = () => {\n    const element = this.leafletElement.getElement();\n    if (!element) return null;\n    return element.querySelector('[data-testid=\"expo-maps-marker-full-size-image\"]');\n  };\n\n  getRectWithIcon = () => {\n    const container = this.rect;\n    const iconElement = this.getIconElement();\n    if (!iconElement) return this.rect;\n    const icon = iconElement.getBoundingClientRect();\n\n    const leftMost = Math.min(icon.x, container.x);\n    const rightMost = Math.max(icon.x + icon.width, container.x + container.width);\n    const topMost = Math.min(icon.y, container.y);\n    const bottomMost = Math.max(icon.y + icon.height, container.y + container.height);\n    return {\n      width: rightMost - leftMost,\n      height: bottomMost - topMost,\n    };\n  };\n\n  onLayoutDidUpdate = () => {\n    const rect = this.getRectWithIcon();\n    this.updateAnchor(this.props.anchor, rect);\n    this.updateCalloutAnchor(this.props.calloutAnchor, rect);\n  };\n\n  observeElementLayout = element => {\n    const resizeObserver = new ResizeObserver(() => {\n      this.onLayoutDidUpdate();\n    }, element);\n    resizeObserver.observe(element);\n    return resizeObserver;\n  };\n\n  observeLayout = container => {\n    if (!this.resizeObserver) {\n      this.resizeObserver = this.observeElementLayout(container);\n    }\n\n    const image = container.querySelector('[data-testid=\"expo-maps-marker-full-size-image\"]');\n    if (image) {\n      this.observeElementLayout(image);\n    }\n  };\n\n  render() {\n    throw new Error('render should be overwritten');\n  }\n}\nclass ReactDivIcon extends ExpoCustomMarker {\n  createLeafletElement(props) {\n    const { map, layerContainer, position, anchor, ...rest } = props;\n\n    const icon = new DivIcon({\n      ...rest,\n      className: '',\n      iconSize: undefined,\n    });\n\n    const options = this.getOptions(props);\n\n    const popupContainer = marker(position, {\n      ...options,\n      icon,\n    });\n    this.contextValue = { ...props.leaflet, popupContainer };\n\n    return popupContainer;\n  }\n\n  render() {\n    const { children, icon } = this.props;\n    const container = this.leafletElement.getElement();\n    if (!container) {\n      return null;\n    }\n\n    this.portal = createPortal(\n      <View>\n        {icon && (\n          <FullSizeImage\n            style={[StyleSheet.absoluteFill, { zIndex: -1 }]}\n            source={{ uri: icon.options.iconUrl }}\n          />\n        )}\n        {children}\n      </View>,\n      container\n    );\n\n    const { LeafletProvider } = RL;\n\n    // this.observeLayout(container);\n\n    return this.portal == null || this.contextValue == null ? null : (\n      <LeafletProvider value={this.contextValue}>{this.portal}</LeafletProvider>\n    );\n  }\n}\n\nclass ReactMarker extends ExpoCustomMarker {\n  createLeafletElement(props) {\n    const el = new LeafletMarker(props.position, this.getOptions(props));\n    this.contextValue = { ...props.leaflet, popupContainer: el };\n    return el;\n  }\n\n  render() {\n    const { children } = this.props;\n\n    const { LeafletProvider } = RL;\n\n    const container = this.leafletElement.getElement();\n    if (!container) {\n      return null;\n    }\n    // this.observeLayout(container);\n    return children == null || this.contextValue == null ? null : (\n      <LeafletProvider value={this.contextValue}>{children}</LeafletProvider>\n    );\n  }\n}\n\nconst ExpoStandardIcon = RL.withLeaflet(ReactMarker);\n\nconst ExpoDivIcon = RL.withLeaflet(ReactDivIcon);\n\nfunction ofPoint(point) {\n  if (!point) return;\n\n  if (Array.isArray(point) && point.length === 2) {\n    return { x: point[0], y: point[1] };\n  }\n  if (point.x !== undefined && point.y !== undefined) {\n    return { x: point.x, y: point.y };\n  }\n  throw new Error('Leaflet.Marker: Point is unexpected type: ' + point);\n}\n"]},"metadata":{},"sourceType":"module"}